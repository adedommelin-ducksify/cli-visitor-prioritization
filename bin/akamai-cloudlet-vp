"""
Copyright 2017 Akamai Technologies, Inc. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
"""

"""
This code leverages akamai OPEN API. to control Visitor Prioritization cloudlets.
In case you need quick explanation contact the initiators.
Initiators: vbhat@akamai.com and aetsai@akamai.com
"""

import json
from akamai.edgegrid import EdgeGridAuth, EdgeRc
from cloudletApiWrapper import cloudlet
import argparse
import configparser
import requests
import os
import sys
import logging
import shutil

PACKAGE_VERSION = "0.1.0"

# Setup logging
if not os.path.exists('logs'):
    os.makedirs('logs')
logFile = os.path.join('logs', 'VPConfigKit_log.log')

# Set the format of logging in console and file seperately
logFormatter = logging.Formatter("%(asctime)s [%(threadName)-12.12s] [%(levelname)-5.5s]  %(message)s")
consoleFormatter = logging.Formatter("%(message)s")
rootLogger = logging.getLogger()

logfileHandler = logging.FileHandler(logFile, mode='w')
logfileHandler.setFormatter(logFormatter)
rootLogger.addHandler(logfileHandler)

consoleHandler = logging.StreamHandler()
consoleHandler.setFormatter(consoleFormatter)
rootLogger.addHandler(consoleHandler)
# Set Log Level to DEBUG, INFO, WARNING, ERROR, CRITICAL
rootLogger.setLevel(logging.INFO)


def initConfig(edgercFile, section):
    if not edgercFile:
        if not os.getenv("AKAMAI_EDGERC"):
            edgercFile = os.path.join(os.path.expanduser("~"), '.edgerc')
        else:
            edgercFile = os.getenv("AKAMAI_EDGERC")

    if not os.access(edgercFile, os.R_OK):
        rootLogger.error("Unable to read edgerc file \"%s\"" % edgercFile)
        exit(1)

    if not section:
        if not os.getenv("AKAMAI_EDGERC_SECTION"):
            section = "cloudlets"
        else:
            section = os.getenv("AKAMAI_EDGERC_SECTION")

    try:
        edgerc = EdgeRc(edgercFile)
        baseurl = edgerc.get(section, 'host')

        session = requests.Session()
        session.auth = EdgeGridAuth.from_edgerc(edgerc, section)

        return baseurl, session
    except configparser.NoSectionError:
        rootLogger.error("Edgerc section \"%s\" not found" % section)
        exit(1)
    except Exception:
        rootLogger.info("Unknown error occurred trying to read edgerc file (%s)" % edgercFile)
        exit(1)


def cli():
    prog = get_prog_name()
    if len(sys.argv) == 1:
        prog += " [command]"

    parser = argparse.ArgumentParser(description='Akamai CLI for Visitor Prioritization', add_help=False, prog=prog)
    parser.add_argument('--version', action='version', version='%(prog)s ' + PACKAGE_VERSION)

    subparsers = parser.add_subparsers(title='Commands', dest="command", metavar="")

    actions = {}

    subparsers.add_parser(name="help", help="Show available help", add_help=False) \
        .add_argument('args', metavar="", nargs=argparse.REMAINDER)

    actions["setup"] = create_sub_command(subparsers, "setup", "Initial setup to download all necessary policy "
                                                               "information")

    actions["show"] = create_sub_command(subparsers, "show", "Display general policy details, active policy versions, "
                                                             "or specific policy version details",
                                         [
                                             {
                                                 "name": "version",
                                                 "help": "Version number of the policy"
                                             },
                                             {
                                                 "name": "verbose",
                                                 "help": "Display detailed rule information for a specific version",
                                                 "action": "store_true"
                                             },
                                             {
                                                 "name": "from-version",
                                                 "help": "Display policy versions starting from the version number specified"
                                             }
                                         ],
                                         [
                                             {
                                                 "name": "policy",
                                                 "help": "Policy name"
                                             }
                                         ])

    actions["generate-rules"] = create_sub_command(subparsers, "generate-rules", "Generate the policy version rules json and output to "
                                                           "rules folder. (Optionally, use -outputfile to specify "
                                                           "location of outputfile)",
                                                   [
                                                       {
                                                           "name": "output-file",
                                                           "help": "Output filename to store the rules"
                                                       }
                                                   ],
                                                   [
                                                       {
                                                           "name": "policy",
                                                           "help": "Policy name"
                                                       },
                                                       {
                                                           "name": "version",
                                                           "help": "Version number of the policy"
                                                       }
                                                   ])

    actions["create-version"] = create_sub_command(subparsers, "create-version", "Create a new policy version using a local file from the "
                                                           "rules folder with name <policy>.json",
                                                   [
                                                       {
                                                           "name": "force",
                                                           "help": "Do not prompt for user confirmation",
                                                           "action": "store_true"
                                                       }
                                                   ],
                                                   [
                                                       {
                                                           "name": "policy",
                                                           "help": "Policy name"
                                                       },
                                                       {
                                                           "name": "file",
                                                           "help": "File path for input rules file"
                                                       }
                                                   ])

    actions["activate"] = create_sub_command(subparsers, "activate", "Activate a specific policy version",
                                             [
                                                 {
                                                     "name": "policy",
                                                     "help": "Policy name"
                                                 }
                                             ],
                                             [
                                                 {
                                                     "name": "network",
                                                     "help": "Network to be activated on (case-insensitive).",
                                                     "type": str.lower,
                                                     "choices": set(("staging", "production"))
                                                 },
                                                 {
                                                     "name": "version",
                                                     "help": "Version number of the policy"
                                                 }
                                             ])

    actions["throttle"] = create_sub_command(subparsers, "throttle", "Throttle traffic by rule name",
                                             [
                                                 {
                                                     "name": "throttle",
                                                     "help": "Throttle value (-1 to 100)"
                                                 },
                                                 {
                                                     "name": "disable",
                                                     "help": "Disable all throttling",
                                                     "action": "store_true"
                                                 },
                                                 {
                                                     "name": "network",
                                                     "help": "Network to be activated on (case-insensitive).",
                                                     "type": str.lower,
                                                     "choices": set(("staging", "production"))
                                                 },
                                                 {
                                                     "name": "rule",
                                                     "help": "Rule name to update (use 'single quotes' to honor "
                                                             "spaces in rule name))"
                                                 },
                                                 {
                                                     "name": "force",
                                                     "help": "Do not prompt for user confirmation",
                                                     "action": "store_true"
                                                 }
                                             ],
                                             [
                                                 {
                                                     "name": "policy",
                                                     "help": "Policy name"
                                                 }
                                             ])

    actions["list"] = create_sub_command(subparsers, "list", "List all Visitor Prioritization policy names")

    args = parser.parse_args()

    if len(sys.argv) <= 1:
        parser.print_help()
        return 0

    if args.command == "help":
        if len(args.args) > 0:
            if actions[args.args[0]]:
                actions[args.args[0]].print_help()
        else:
            parser.prog = get_prog_name() + " help [command]"
            parser.print_help()
        return 0

    if args.command != "setup":
        confirm_setup(args)

    return getattr(sys.modules[__name__], args.command.replace("-", "_"))(args)


def create_sub_command(subparsers, name, help, optional_arguments=None, required_arguments=None):
    action = subparsers.add_parser(name=name, help=help, add_help=False)

    if required_arguments:
        required = action.add_argument_group("required arguments")
        for arg in required_arguments:
            name = arg["name"]
            del arg["name"]
            required.add_argument("--" + name,
                                  **arg,
                                  required=True
                                  )

    optional = action.add_argument_group("optional arguments")
    if optional_arguments:
        for arg in optional_arguments:
            name = arg["name"]
            del arg["name"]
            optional.add_argument("--" + name,
                                  **arg,
                                  required=False
                                  )

    optional.add_argument("--edgerc",
                          help="Location of the credentials file [$AKAMAI_EDGERC]",
                          default=os.path.join(os.path.expanduser("~"), '.edgerc'))

    optional.add_argument("--section",
                          help="Section of the credentials file [$AKAMAI_EDGERC_SECTION]",
                          default="cloudlets")

    optional.add_argument("--debug",
                          help="DEBUG mode to generate additional logs for troubleshooting",
                          action="store_true")

    return action


def setup(args):
    baseUrl, session = initConfig(args.edgerc, args.section)

    rootLogger.info('Setting up required files... please wait')
    # Create the wrapper object to make calls
    cloudletObject = cloudlet(baseUrl)
    groupResponse = cloudletObject.listCloudletGroups(session)
    rootLogger.info('Processing groups...')
    if groupResponse.status_code == 200:
        groupPath = 'groups'
        # Delete the groups folder before we start
        if os.path.exists('groups'):
            shutil.rmtree('groups')
        if not os.path.exists(groupPath):
            os.makedirs(groupPath)
        with open(os.path.join(groupPath, 'groups.json'), 'w') as groupFile:
            groupsResponseJson = groupResponse.json()
            # Find number of groups using len function
            totalGroups = len(groupsResponseJson)
            groupOutput = []
            for everyGroup in groupsResponseJson:
                groupInfo = {}
                groupInfo['groupName'] = everyGroup['groupName']
                groupInfo['groupId'] = everyGroup['groupId']
                groupOutput.append(groupInfo)
            groupFile.write(json.dumps(groupOutput, indent=4))

        policyPath = os.path.join(get_cache_dir(), 'policies')
        policiesList = []
        # Delete the policies folder before we start
        if os.path.exists('policies'):
            shutil.rmtree('policies')
        if not os.path.exists(policyPath):
            os.makedirs(policyPath)
        rootLogger.info('Total groups found: ' + str(totalGroups))
        rootLogger.info('Fetching VP cloudlet policies under each group..')
        counter = 1
        for everyGroup in groupResponse.json():
            groupId = everyGroup['groupId']
            groupName = everyGroup['groupName']
            rootLogger.info(
                'Processing ' + str(counter) + ' of ' + str(totalGroups) + ' groups, groupId and name is: ' + str(
                    groupId) + ': ' + groupName)
            counter += 1
            cloudletPolicies = cloudletObject.listPolicies(session=session, groupId=groupId, cloudletCode='VP')
            if cloudletPolicies.status_code == 200:
                for everyPolicy in cloudletPolicies.json():
                    policyName = everyPolicy['name'] + '.json'
                    rootLogger.debug('Generating policy file: ' + policyName)
                    policyDetails = {}
                    policyDetails['name'] = everyPolicy['name']
                    policyDetails['description'] = everyPolicy['description']
                    policyDetails['policyId'] = everyPolicy['policyId']
                    policyDetails['groupId'] = everyPolicy['groupId']
                    if everyPolicy['name'] not in policiesList:
                        policiesList.append(everyPolicy['name'])
                        with open(os.path.join(policyPath, policyName), 'w') as policyFileHandler:
                            policyFileHandler.write(json.dumps(policyDetails, indent=4))
                    else:
                        # This policy is already processed so move on
                        rootLogger.debug('Duplicate policy in another group again ' + everyPolicy['name'])
                        pass
            else:
                rootLogger.debug('groupId: ' + str(groupId) + ' has no policy details')
        rootLogger.info('\nFound these policies below and stored in ' + policyPath + " folder:")
        for everyPolicyName in policiesList:
            print(everyPolicyName)

    return 0


def show(args):
    baseUrl, session = initConfig(args.edgerc, args.section)

    policy = args.policy
    version = args.version
    verbose = args.verbose
    fromVersion = args.from_version

    cloudletObject = cloudlet(baseUrl)
    policiesFolder = os.path.join(get_cache_dir(), 'policies')
    for root, dirs, files in os.walk(policiesFolder):
        localPolicyFile = policy + '.json'
        if localPolicyFile in files:
            # rootLogger.info(policy + ' Found')
            with open(os.path.join(policiesFolder, localPolicyFile), mode='r') as policyFileHandler:
                policyStringContent = policyFileHandler.read()
            # rootLogger.info(policyStringContent)
            policyJsonContent = json.loads(policyStringContent)
            policy_groupId = policyJsonContent['groupId']
            policy_policyId = policyJsonContent['policyId']
            rootLogger.info('Fetching policy details...')
            if version:
                policyDetail = cloudletObject.getCloudletPolicy(session, policy_policyId, version=args.version)
                rootLogger.debug(json.dumps(policyDetail.json()))
                everyVersionDetail = policyDetail.json()
                if policyDetail.status_code == 200:
                    if not everyVersionDetail['deleted']:
                        rootLogger.info('\nDetails of version: ' + str(everyVersionDetail['version']))
                        rootLogger.info('Policy created by: ' + everyVersionDetail['createdBy'] + '\n')
                        # Need to check for match rules, sometimes we see null values
                        if everyVersionDetail['matchRules'] is not None:
                            if not verbose:
                                for everyMatchRule in everyVersionDetail['matchRules']:
                                    multipleMatches = 0
                                    # Loop each match conditon within each rule
                                    # Check wthether rules is disabled, if yes display accordingly
                                    if 'disabled' in everyMatchRule and everyMatchRule['disabled'] is True:
                                        status = 'DISABLED'
                                    else:
                                        status = 'ACTIVE'
                                    print('   ' + everyMatchRule['name'] + ' -> ' + str(
                                        everyMatchRule['passThroughPercent']) + ' -> ' + status)
                                print(
                                    '\nNOTE: You can pass -verbose as an additional argument to get detailed rule information')
                            if verbose:
                                rootLogger.info('     Match Criteria and Rule Details are: ')
                                rootLogger.info('\n       ----------------------------------------------       \n')
                                for everyMatchRule in everyVersionDetail['matchRules']:
                                    multipleMatches = 0
                                    rootLogger.info('       Rule Name: ' + everyMatchRule['name'])
                                    rootLogger.info(
                                        '       Traffic Percentage: ' + str(everyMatchRule['passThroughPercent']))
                                    rootLogger.info('')
                                    # Loop each match conditon within each rule
                                    for everyMatchCondition in everyMatchRule['matches']:
                                        if multipleMatches == 1:
                                            rootLogger.info('       AND')
                                        rootLogger.info('       Match Type: ' + everyMatchCondition['matchType'])
                                        rootLogger.info('       Match Value: ' + everyMatchCondition['matchValue'])
                                        multipleMatches = 1
                                    # Check wthether rules is disabled, if yes display accordingly
                                    if 'disabled' in everyMatchRule and everyMatchRule['disabled'] is True:
                                        rootLogger.info('\n       Rule is DISABLED')
                                    else:
                                        rootLogger.info('\n       Rule is ACTIVE')
                                    rootLogger.info('\n       ----------------------------------------------       \n')
                        else:
                            rootLogger.info('\nThere are no match criterias for this rule\n')
                else:
                    rootLogger.info('Requested policy version does not exist - please check version number')
            else:
                policyDetails = cloudletObject.getCloudletPolicy(session, policy_policyId)
                # rootLogger.info(json.dumps(policyDetails.json()))
                rootLogger.info('\nPolicy Details:')
                rootLogger.info('-----------------')
                rootLogger.info('Policy Description: ' + policyDetails.json()['description'] + '\n')
                for everyactivationDetail in policyDetails.json()['activations']:
                    if everyactivationDetail['policyInfo']['status'] == 'active':
                        rootLogger.info(
                            'Version ' + str(everyactivationDetail['policyInfo']['version']) + ' is live in ' + str(
                                everyactivationDetail['network']) + ' for configuration: ' + str(
                                everyactivationDetail['propertyInfo']['name']) + ' v' + str(
                                everyactivationDetail['propertyInfo']['version']))

                if not fromVersion:
                    policyVersions = cloudletObject.listPolicyVersions(session, policy_policyId, pageSize='10')
                    rootLogger.info(
                        '\nFetching last 10 policy version details... You can pass -fromVersion to list more versions.')
                else:
                    policyVersions = cloudletObject.listPolicyVersions(session, policy_policyId)
                    rootLogger.info('\nShowing policy version details from version ' + str(fromVersion))
                rootLogger.info('\nVersion Details (Version : Description)')
                rootLogger.info('------------------------------------------')
                for everyVersion in policyVersions.json():
                    if fromVersion:
                        if int(everyVersion['version']) >= int(fromVersion):
                            rootLogger.info(str(everyVersion['version']) + ' : ' + str(everyVersion['description']))
                    else:
                        rootLogger.info(str(everyVersion['version']) + ' : ' + str(everyVersion['description']))

                rootLogger.info(
                    '\nNOTE: You can pass -version <version_number> as an additional argument to get version specific '
                    'details\n')

        else:
            rootLogger.info(
                '\nLocal datastore does not have this policy. Please double check policy name or run -setup first')
            exit(1)


def generate_rules_json(args):
    baseUrl, session = initConfig(args.edgerc, args.section)

    policy = args.policy
    version = args.version
    output_file = args.output_file

    cloudletObject = cloudlet(baseUrl)
    policiesFolder = os.path.join(get_cache_dir(), 'policies')
    for root, dirs, files in os.walk(policiesFolder):
        localPolicyFile = policy + '.json'
        if localPolicyFile in files:
            # rootLogger.info(policy + ' Found')
            with open(os.path.join(policiesFolder, localPolicyFile), mode='r') as policyFileHandler:
                policyStringContent = policyFileHandler.read()
            # rootLogger.info(policyStringContent)
            policyJsonContent = json.loads(policyStringContent)
            policy_groupId = policyJsonContent['groupId']
            policy_policyId = policyJsonContent['policyId']
            rootLogger.info('\nFetching policy rule details...')
            policyDetails = cloudletObject.getCloudletPolicy(session, policy_policyId, version=version)
            if policyDetails.status_code == 200:
                # rootLogger.info(json.dumps(policyDetails.json()))
                # Update the local copy to latest details
                if output_file:
                    outputfilename = output_file
                else:
                    newPolicyFolder = 'rules'
                    if not os.path.exists(newPolicyFolder):
                        os.makedirs(newPolicyFolder)
                    newPolicyFile = policy + '_rules.json'
                    outputfilename = os.path.join(newPolicyFolder, newPolicyFile)
                policyDetailsToFile = {}
                everyDetailofPolicy = policyDetails.json()
                if 'description' in everyDetailofPolicy:
                    policyDetailsToFile['description'] = everyDetailofPolicy['description']
                if 'matchRules' in everyDetailofPolicy:
                    # Check whether it is null value
                    if everyDetailofPolicy['matchRules'] is not None:
                        matchRulesSection = everyDetailofPolicy['matchRules']
                        for everyMatchRule in matchRulesSection:
                            if 'location' in everyMatchRule:
                                del everyMatchRule['location']
                        policyDetailsToFile['matchRules'] = everyDetailofPolicy['matchRules']
                if 'description' in everyDetailofPolicy is None:
                    policyDetailsToFile['description'] = 'This is a version created using API'

                with open(outputfilename, mode='w') as policyFileHandler:
                    policyFileHandler.write(json.dumps(policyDetailsToFile, indent=4))
                rootLogger.info(
                    '\nGenerated policy rule details in json format. File output location is: ' + outputfilename)
            else:
                rootLogger.info('Unable to fetch version details. Check the version number')
                return 1
        else:
            rootLogger.info(
                '\nLocal datastore does not have this policy. Please double check policy name or run -setup first')
            return 1

    return 0


def create_version(args):
    baseUrl, session = initConfig(args.edgerc, args.section)

    if not args.force:
        rootLogger.info('\nThe description field will be used as comments for this version\n')
        rootLogger.info('\nDoes your rules json file have the proper description field updated? [y/N]\n')
        if not str.lower(input()) == "y":
            rootLogger.info('\nExiting the program, you may run it again after updating description\n')
            return 1

    policy = args.policy
    file = args.file

    cloudletObject = cloudlet(baseUrl)
    policiesFolder = os.path.join(get_cache_dir(), 'policies')
    for root, dirs, files in os.walk(policiesFolder):
        localPolicyFile = policy + '.json'
        if localPolicyFile in files:
            rootLogger.info('Found policy: ' + policy + ' and using policyId from local store...')
            with open(os.path.join(policiesFolder, localPolicyFile), mode='r') as policyFileHandler:
                policyStringContent = policyFileHandler.read()
            # rootLogger.info(policyStringContent)
            policyJsonContent = json.loads(policyStringContent)
            policy_groupId = policyJsonContent['groupId']
            policy_policyId = policyJsonContent['policyId']

            newPolicyFolder = 'rules'
            newPolicyFile = policy + '_rules.json'
            if file:
                customFile = file
                rulesFile = os.path.join(newPolicyFolder, customFile)
            else:
                rootLogger.info(
                    '\n-file option was not specified. Picking rules file from: ' + os.path.join(newPolicyFolder,
                                                                                                 newPolicyFile))
                rulesFile = os.path.join(newPolicyFolder, newPolicyFile)
            try:
                with open(rulesFile, mode='r') as policyData:
                    policyDetails = json.load(policyData)
                    policyDetailsJson = json.dumps(policyDetails)
                policyCreateResponse = cloudletObject.createPolicyVersion(session, policyId=policy_policyId)
                rootLogger.info('Trying to create a new version of this policy...')
                if policyCreateResponse.status_code == 200 or 201:
                    newVersion = policyCreateResponse.json()['version']
                    policyUpdateResponse = cloudletObject.updatePolicyVersion(session, policy_policyId,
                                                                              policyDetailsJson, newVersion)
                    if policyUpdateResponse.status_code == 200:
                        rootLogger.info(
                            'Success! Created policy version number ' + str(policyUpdateResponse.json()['version']))
                    else:
                        rootLogger.info(
                            'Cannot create new policy version, Reason: ' + policyUpdateResponse.json()['detail'])
                        rootLogger.debug('Detailed Json response is: ' + policyUpdateResponse.json())
                else:
                    rootLogger.info('Unable to create the policy.')
            except FileNotFoundError:
                rootLogger.info('\n' + os.path.join(newPolicyFolder,
                                                    newPolicyFile) + ' is not found. This file is the default source for uploading rules.\n')
                rootLogger.info('You may want to use -generateRulesJson <policyname> first\n')
        else:
            rootLogger.info(
                '\nLocal datastore does not have this policy. Please double check policy name or run -setup first')

    return 0

def activate(args):
    baseUrl, session = initConfig(args.edgerc, args.section)

    policy = args.policy
    version = args.version
    network = args.network

    if network == 'production':
        network = 'prod'

    cloudletObject = cloudlet(baseUrl)
    policiesFolder = os.path.join(get_cache_dir(), 'policies')
    for root, dirs, files in os.walk(policiesFolder):
        localPolicyFile = policy + '.json'
        if localPolicyFile in files:
            rootLogger.info(policy + ' file is Found... Using policyId from local store...')
            with open(os.path.join(policiesFolder, localPolicyFile), mode='r') as policyFileHandler:
                policyStringContent = policyFileHandler.read()
            policyJsonContent = json.loads(policyStringContent)
            policy_groupId = policyJsonContent['groupId']
            policy_policyId = policyJsonContent['policyId']

            # Update the local copy to latest details
            rootLogger.info(
                'Trying to activate policy ' + policy + ' version ' + version + ' to ' + network + ' network')

            activationResponse = cloudletObject.activatePolicyVersion(session, policy_policyId, version, network)
            if activationResponse.status_code == 200:
                rootLogger.info('Success! Policy version is activated')
            else:
                rootLogger.info('Unable to activate, check the version number.')
                return 1
        else:
            rootLogger.info(
                '\nLocal datastore does not have this policy. Please double check policy name or run "setup" first')
            return 1

    return 0


def throttle(args):
    baseUrl, session = initConfig(args.edgerc, args.section)

    policy = args.policy
    network = args.network
    rule = args.rule
    throttle = args.throttle.lower()
    disable = args.disable
    force = args.force

    if not disable and not throttle:
        print("One of --throttle or --disable must be specified")
        return 1

    if -1 <= int(throttle) <= 100:
        print("Invalid --throttle value, please specify a value between -1 and 100")
        return 1

    if not force:
        if not disable:
            rootLogger.info('You are about to throttle ' + rule + ' at value = ' + str(
                throttle) + ' for ' + policy + ' on the Akamai ' + network + ' network. Do you wish to continue? [y/N]')
        else:
            rootLogger.info(
                'You are about to disable ' + rule + ' for ' + policy + ' on the Akamai ' + network + ' network. Do you wish to continue? [y/N]')

        if str.lower(input()) != 'y':
            rootLogger.info('Exiting...')

    if network == 'production':
        network = 'prod'

    cloudletObject = cloudlet(baseUrl)
    policiesFolder = os.path.join(get_cache_dir(), 'policies')
    for root, dirs, files in os.walk(policiesFolder):
        localPolicyFile = policy + '.json'
        # Read the policy file to fetch policy ID
        if localPolicyFile in files:
            with open(os.path.join(policiesFolder, localPolicyFile), mode='r') as policyFileHandler:
                policyStringContent = policyFileHandler.read()
            policyJsonContent = json.loads(policyStringContent)
            policy_groupId = policyJsonContent['groupId']
            policy_policyId = policyJsonContent['policyId']
            rootLogger.info('Fetching policy details...')

            # Fetch policy details to identify the version
            policyDetails = cloudletObject.getCloudletPolicy(session, policy_policyId)
            stagingVersion = str(-1)
            prodVersion = str(-1)
            for everyactivationDetail in policyDetails.json()['activations']:
                if everyactivationDetail['policyInfo']['status'] == 'active':
                    if everyactivationDetail['network'] == 'staging':
                        stagingVersion = str(everyactivationDetail['policyInfo']['version'])
                    elif everyactivationDetail['network'] == 'prod':
                        prodVersion = str(everyactivationDetail['policyInfo']['version'])

            # Check which network is of interest, and base the version number
            if network == 'staging' and stagingVersion != '-1':
                version = stagingVersion
            elif network == 'prod' and prodVersion != '-1':
                version = prodVersion
            else:
                rootLogger.info('No current version live in ' + network + ' network. Exiting...')
                exit(1)

            rootLogger.info('Found version ' + version + ' live in ' + network + ' network. Using this version...')
            policyDetails = cloudletObject.getCloudletPolicy(session, policy_policyId, version=version)
            # rootLogger.info(json.dumps(policyDetails.json(), indent = 4))

            # Filter the details of policy
            ruleFound = 0
            ruleCount = 0
            policyDetailsToModify = {}
            everyDetailofPolicy = policyDetails.json()
            rootLogger.info('\nSearching for Rule: ' + rule)
            if 'matchRules' in everyDetailofPolicy:
                # Check whether it is null value
                if everyDetailofPolicy['matchRules'] is None:
                    rootLogger.info('No rules exist in the policy. Exiting...')
                    exit(1)
                if everyDetailofPolicy['matchRules'] is not None:
                    matchRulesSection = everyDetailofPolicy['matchRules']
                    for everyMatchRule in matchRulesSection:
                        # Delete the location tag, as it causes error while uploading
                        if 'location' in everyMatchRule:
                            del everyMatchRule['location']
                        # Match the rule name (case insensitive)
                        if everyMatchRule['name'].lower() == rule.lower():
                            # Update the throttle value now
                            ruleFound = 1
                            ruleCount = ruleCount + 1
                            if not disable:
                                everyMatchRule['passThroughPercent'] = int(throttle)
                                # Check wthether rules is disabled, if yes enable it by deleting the disable entry
                                if 'disabled' in everyMatchRule and everyMatchRule['disabled'] is True:
                                    del everyMatchRule['disabled']
                            if disable == 'disabled':
                                everyMatchRule['disabled'] = True

                    policyDetailsToModify['matchRules'] = everyDetailofPolicy['matchRules']
                    policyDetailsToModify['description'] = 'Created from v' + str(
                        version) + ': Throttle Rule = ' + rule + ' to value = ' + str(
                        throttle) + ' (Akamai CLI for Visitor Prioritization)'
                    if ruleFound == 0:
                        rootLogger.info('Rule: ' + rule + ' is not found. Exiting...')
                        return 1
                    if ruleCount == 1:
                        rootLogger.info('1 rule has been found...')
                    else:
                        rootLogger.info(str(ruleCount) + ' rules have been found...')
            else:
                rootLogger.info('No rules exist in the policy. Exiting...')
                return 1

            # Let us now create a new version and update the rules
            policyCreateResponse = cloudletObject.createPolicyVersion(session, policyId=policy_policyId)
            rootLogger.info('\nTrying to create a new version of this policy with updated rule throttle.')
            if policyCreateResponse.status_code == 200 or 201:
                newVersion = policyCreateResponse.json()['version']
                # Let us now update the rules with new throttle values
                policyUpdateResponse = cloudletObject.updatePolicyVersion(session, policy_policyId,
                                                                          json.dumps(policyDetailsToModify),
                                                                          newVersion)
                if policyUpdateResponse.status_code == 200:
                    rootLogger.info(
                        'Successfully created new policy version : v' + str(policyUpdateResponse.json()['version']))
                    # Let us now activate the version
                    rootLogger.info('Now activating v' + str(
                        policyUpdateResponse.json()['version']) + ' to Akamai ' + network + ' network ')
                    activationResponse = cloudletObject.activatePolicyVersion(session, policy_policyId, str(
                        policyUpdateResponse.json()['version']), network)
                    if activationResponse.status_code == 200:
                        rootLogger.info('Success! Throttle change is live...')
                    else:
                        rootLogger.info('Unable to activate, check for invalid version')
                        return 1
                else:
                    rootLogger.info(
                        'Cannot create new policy version, Reason: ' + str(policyUpdateResponse.json()['detail']))
                    rootLogger.debug('Detailed Json response is: ' + str(policyUpdateResponse.json()))
                    return 1
            else:
                rootLogger.info('Unable to create the new version of policy.')
                return 1
        else:
            rootLogger.info(
                '\nLocal datastore does not have this policy. Please double check policy name or run -setup first')
            return 1

    return 0


def list(args):
    counter = 1
    policiesFolder = os.path.join(get_cache_dir(), 'policies')

    rootLogger.info('\n\nAvailable policies are: ')
    rootLogger.info('--------------------------\n')
    for root, dirs, files in os.walk(policiesFolder):
        for everyFile in files:
            if everyFile.endswith('json'):
                filenName = everyFile.split('.')
                rootLogger.info(str(counter) + '. ' + filenName[0])
                counter += 1
    rootLogger.info('\n--------------------------\n')

    return 0


def confirm_setup(args):
    policiesDir = os.path.join(get_cache_dir(), 'policies')

    if not os.access(policiesDir, os.W_OK):
        print("Cache not found. You must create it to continue [Y/n]:", end=' ')

        if str.lower(input()) == 'n':
            rootLogger.info('Exiting.')
            exit(1)

        return setup(args)

    return


def get_prog_name():
    prog = os.path.basename(sys.argv[0])
    if os.getenv("AKAMAI_CLI"):
        prog = "akamai cloudlet-vp"
    return prog


def get_cache_dir():
    if os.getenv("AKAMAI_CLI_CACHE_DIR"):
        return os.getenv("AKAMAI_CLI_CACHE_DIR")

    return os.curdir


if __name__ == '__main__':
    try:
        status = cli()
        exit(status)
    except KeyboardInterrupt:
        exit(1)